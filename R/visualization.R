
#scatter plot, heatmap, residual plot, local R square plot, clock plot####

#'Draw a scatter plot to compare the model predicted and true values of the 
#'  response variable
#'
#'Draw a scatter plot to compare the model predicted and true values of the 
#'  response variable to show the performance of the model.
#'
#'@param comptab A matrix or data.frame with the predicted and true response 
#'  values. Each row is a sample, and a column named "Prediction" should be 
#'  used to record the model predicted values, while a column named "True" 
#'  should be used to record the corresponding true values. They should be 
#'  numeric values. In the results generated by the function 
#'  \code{singleselection}, \code{singlebalance} or \code{crosstraining}, the 
#'  slots named "traincomp" and "testcomp" can be used directly as the input 
#'  of this parameter.
#'@param featurenum Number of features used by the model to predict response. 
#'  Will be shown in the subtitle of the plot. Default is NULL, which means 
#'  this information will not be shown in the plot.
#'@param title The title of the plot.
#'@param colorful Whether the dots in the scatter plot should be colored using 
#'  gradually changed colors to reflect the density of the dots in the plot. 
#'  If it is set as TRUE and the total dot number is greater than 50, the 
#'  density color will be used. Default is FALSE.
#'@return A scatter plot showing the comparison between the model predicted 
#'  and true values of the response variable.
#'@export
scatterplot <- function(comptab, 
                        featurenum = NULL, 
                        title, 
                        colorful = FALSE){
  
  samplenum <- nrow(comptab)
  
  if(!is.null(featurenum)){
    subtitle <- paste0('(', featurenum, ' features on ', samplenum, ' samples)')
  }else{
    subtitle <- paste0('(', samplenum, ' samples)')
    
  }
  
  comptab <- as.data.frame(comptab, stringsAsFactors = FALSE)
  pcc <- cor(comptab$Prediction, comptab$True)
  pcc <- signif(pcc, 3)
  
  lmfit <- lm(formula = Prediction~True, data = comptab)
  inter <- as.vector(coefficients(lmfit))[1]
  slope <- as.vector(coefficients(lmfit))[2]
  
  if(inter > 0){
    equalsign <- ' + '
    absinter <- signif(inter, 3)
  }else if(inter < 0){
    equalsign <- ' - '
    absinter <- signif(abs(inter), 3)
  }else{
    equalsign <- ''
    absinter <- ''
  }
  
  form <- paste0('y = ', signif(slope, 3), 'x', equalsign, absinter)
  
  lm_eqn <- function(comptab){
    m <- lm(Prediction ~ True, comptab);
    eq <- substitute(~~italic(R^2~"="~r2), 
                     list(r2 = format(summary(m)$r.squared, digits = 3)))
    as.character(as.expression(eq));
  }
  
  xrange <- range(comptab$True)
  yrange <- range(comptab$Prediction)
  xlen <- abs(xrange[2] - xrange[1])
  ylen <- abs(yrange[2] - yrange[1])
  x1 <- xrange[1] + xlen*1/4
  y1 <- yrange[1] + ylen*3/4
  x2 <- xrange[1] + xlen*3/4
  y2 <- yrange[1] + ylen*1/4
  
  
  myColor <- rep('blue', nrow(comptab))
  
  if(colorful == TRUE & nrow(comptab) > 50){
    
    myColor <- densCols(x = comptab$True, y = comptab$Prediction, 
                        colramp = colorRampPalette(rev(rainbow(10, end=4/6))))
    
  }
  
  comptab$denscolor <- myColor
  rgbmat <- t(col2rgb(myColor))
  rgbmat <- as.data.frame(rgbmat, stringsAsFactors = FALSE)
  comptab <- cbind(comptab, rgbmat)
  comptab <- comptab[order(-comptab$blue, comptab$red, comptab$green),]
  comptab1 <- subset(comptab, blue >= red)
  comptab2 <- subset(comptab, blue < red)
  comptab2 <- comptab2[order(-comptab2$blue, comptab2$red, -comptab2$green),]
  comptab <- rbind(comptab1, comptab2)
  
  
  p <- ggplot2::ggplot(comptab, ggplot2::aes(x=True, y=Prediction))
  
  print(
    p + ggplot2::geom_point(color=comptab$denscolor, position='jitter') + 
      ggplot2::xlab('True values') + 
      ggplot2::ylab('Predicted values') + 
      ggplot2::ggtitle(title, subtitle = subtitle) + 
      ggplot2::geom_abline(slope = slope, intercept = inter, color = 'red', size = 1) + 
      ggplot2::geom_text(x = x1, y = y1, label = lm_eqn(comptab), parse = TRUE, size = 5, color = 'red') + 
      ggplot2::annotate('text', label = paste0('bolditalic("', form, '")'), 
                        x = x2, y = y2, size = 5, color = 'red', parse = TRUE) + 
      ggplot2::theme_bw()
  )
  
  
}

#'Draw a heatmap to show the features and the response variable
#'
#'Draw a heatmap to show the features and the predicted and true response 
#'  values.
#'
#'@param orivar A matrix with the feature values need to be displayed in the 
#'  heatmap. Each row represents one sample and each column represents one 
#'  feature. The column names are the feature names while the row names should 
#'  be sample IDs. Each column records a series of numeric values.
#'@param comptab A matrix or data.frame with the predicted and true response 
#'  values. Each row is a sample, and a column named "Prediction" should be 
#'  used to record the model predicted values, while a column named "True" 
#'  should be used to record the corresponding true values. They should be 
#'  numeric values. The row names should be sample IDs same as that in the 
#'  \code{orivar} matrix. In the results generated by the function 
#'  \code{singleselection}, \code{singlebalance} or \code{crosstraining}, the 
#'  slots named "traincomp" and "testcomp" can be used directly as the input 
#'  of this parameter.
#'@param featurenames Name of features used by the model to predict response 
#'  that will be shown by the heatmap. Default is NULL, which means all the 
#'  features included in the \code{orivar} matrix will be shown. If want to 
#'  show the features (the rows in the heatmap) with a specific order, this 
#'  parameter need to be given as a vector with the ordered feature names.
#'@param title The title of the plot.
#'@return Three heatmaps will be shown. For all of them, a row is a feature, 
#'  and a column is a sample. The first heatmap has the samples ordered by 
#'  their true response values. The second one has the samples ordered by 
#'  their predicted response values. While the features are ordered according 
#'  to the parameter \code{featurenames}. The third heatmap has both the 
#'  samples and the features hierarchically clustered using a "complete" 
#'  method.
#'@export
heatmapplot <- function(orivar, 
                        comptab, 
                        featurenames = NULL, 
                        title){
  
  if(!is.null(featurenames)){
    heatmapmatrix <- orivar[,featurenames]
  }else{
    heatmapmatrix <- orivar
  }
  
  heatmapmatrix <- t(heatmapmatrix)
  
  comptab <- as.data.frame(comptab, stringsAsFactors = FALSE)
  
  heatmappd <- comptab[order(comptab$True),]
  heatmapmatrix <- heatmapmatrix[,row.names(heatmappd)]
  colnames(heatmappd) <- c('Predicted Response', 'True Response')
  
  print(
    
    pheatmap::pheatmap(heatmapmatrix, scale = 'row', 
                       color = colorRampPalette(colors = c('green', 'black', 'red'))(100), 
                       show_colnames = FALSE, show_rownames = FALSE, 
                       main = paste0(title, ' ', 
                                     nrow(heatmapmatrix), ' features on ', 
                                     ncol(heatmapmatrix), ' sampels'), 
                       annotation_col = heatmappd, 
                       cluster_cols = FALSE, 
                       cluster_rows = FALSE, 
                       border_color = NA)
    
  )
  
  
  heatmappd <- comptab[order(comptab$Prediction),]
  heatmapmatrix <- heatmapmatrix[,row.names(heatmappd)]
  colnames(heatmappd) <- c('Predicted Response', 'True Response')
  
  print(
    
    pheatmap::pheatmap(heatmapmatrix, scale = 'row', 
                       color = colorRampPalette(colors = c('green', 'black', 'red'))(100), 
                       show_colnames = FALSE, show_rownames = FALSE, 
                       main = paste0(title, ' ', 
                                     nrow(heatmapmatrix), ' features on ', 
                                     ncol(heatmapmatrix), ' sampels'), 
                       annotation_col = heatmappd, 
                       cluster_cols = FALSE, 
                       cluster_rows = FALSE, 
                       border_color = NA)
    
  )
  
  print(
    
    pheatmap::pheatmap(heatmapmatrix, scale = 'row', 
                       color = colorRampPalette(colors = c('green', 'black', 'red'))(100), 
                       show_colnames = FALSE, show_rownames = FALSE, 
                       main = paste0(title, ' ', 
                                     nrow(heatmapmatrix), ' features on ', 
                                     ncol(heatmapmatrix), ' sampels'), 
                       annotation_col = heatmappd, 
                       cluster_cols = TRUE, 
                       cluster_rows = TRUE, 
                       border_color = NA)
    
  )
  
}

#'Plot the true sample response-sample residual relationship
#'
#'Draw a scatter plot to show the relationship between the true response 
#'  values and the sample residuals of the model.
#'
#'@param comptab A matrix or data.frame with the predicted and true response 
#'  values. Each row is a sample, and a column named "Prediction" should be 
#'  used to record the model predicted values, while a column named "True" 
#'  should be used to record the corresponding true values. They should be 
#'  numeric values. In the results generated by the function 
#'  \code{singleselection}, \code{singlebalance} or \code{crosstraining}, the 
#'  slots named "traincomp" and "testcomp" can be used directly as the input 
#'  of this parameter.
#'@param featurenum Number of features used by the model to predict response. 
#'  Will be shown in the subtitle of the plot. Default is NULL, which means 
#'  this information will not be shown in the plot.
#'@param title The title of the plot.
#'@param colorful Whether the dots in the plot should be colored using 
#'  gradually changed colors to reflect the density of the dots in the plot. 
#'  If it is set as TRUE and the total dot number is greater than 50, the 
#'  density color will be used. Default is FALSE.
#'@return A scatter plot showing the true sample response-sample residual 
#'  relationship.
#'@export
residualplot <- function(comptab, 
                         featurenum = NULL, 
                         title, 
                         colorful = FALSE){
  
  comptab <- as.data.frame(comptab)
  
  residuals <- comptab$True - comptab$Prediction
  comptab <- cbind(comptab, residuals)
  
  samplenum <- nrow(comptab)
  if(!is.null(featurenum)){
    subtitle <- paste0('(', featurenum, ' features on ', samplenum, ' samples)')
  }else{
    subtitle <- paste0('(', samplenum, ' samples)')
    
  }
  
  myColor <- rep('blue', nrow(comptab))
  
  if(colorful == TRUE & nrow(comptab) > 50){
    
    myColor <- densCols(x = comptab$True, y = comptab$residuals, 
                        colramp = colorRampPalette(rev(rainbow(10, end=4/6))))
    
  }
  
  comptab$denscolor <- myColor
  rgbmat <- t(col2rgb(myColor))
  rgbmat <- as.data.frame(rgbmat, stringsAsFactors = FALSE)
  comptab <- cbind(comptab, rgbmat)
  comptab <- comptab[order(-comptab$blue, comptab$red, comptab$green),]
  comptab1 <- subset(comptab, blue >= red)
  comptab2 <- subset(comptab, blue < red)
  comptab2 <- comptab2[order(-comptab2$blue, comptab2$red, -comptab2$green),]
  comptab <- rbind(comptab1, comptab2)
  
  p <- ggplot2::ggplot(comptab, ggplot2::aes(x=True, y=residuals))
  
  print(
    p + ggplot2::geom_point(color=comptab$denscolor, position='jitter') + 
      ggplot2::xlab('True values') + 
      ggplot2::ylab('Residuals') + 
      ggplot2::ggtitle(title, subtitle = subtitle) + 
      ggplot2::geom_smooth(se = FALSE, fullrange = TRUE) + 
      ggplot2::geom_hline(yintercept = 0, color = 'red', size = 1, 
                          linetype = 2) + 
      ggplot2::theme_bw()
  )
  
}

#'Plot the sample response-sample residual relationship for multiple models
#'
#'Draw a scatter plot to show the sample response-sample residual relationship 
#'  for multiple models.
#'
#'@param comptabs A list with more than one matrix or data.frame as elements, 
#'  Each matrix or data.frame corresponds to one model and should contain the 
#'  predicted and true response values of that model. Each row is a sample, 
#'  and a column named "Prediction" should be used to record the model 
#'  predicted values, while a column named "True" should be used to record the 
#'  corresponding true values. They should be numeric values. In the results 
#'  generated by the function \code{singleselection}, \code{singlebalance} or 
#'  \code{crosstraining}, the slots named "traincomp" and "testcomp" can be 
#'  used as these matrices or data.frames.
#'@param title The title of the plot.
#'@param methodnames A vector containing the names of the models. It 
#'  corresponds to the list of \code{comptabs} and its length should be the 
#'  same as the list length.
#'@return A plot showing the true sample response-sample residual relationship 
#'  for multiple models.
#'@export
residualcomp <- function(comptabs, 
                         title, 
                         methodnames){
  
  if(length(comptabs) <= 1){
    return(NULL)
  }
  
  for(i in 1:(length(comptabs) - 1)){
    
    comptab1 <- comptabs[[i]]
    comptab2 <- comptabs[[i + 1]]
    comp <- sum(row.names(comptab1) != row.names(comptab2))
    if(i == 1){
      comps <- comp
    }else{
      comps <- comps + comp
    }
    
  }
  
  #if(comps >= 1){
  #  return(NULL)
  #}
  
  
  samplenum <- nrow(comptab1)
  
  for(i in 1:length(comptabs)){
    
    comptab <- as.data.frame(comptabs[[i]])
    
    residuals <- comptab$True - comptab$Prediction
    comptab <- cbind(comptab, residuals)
    
    names(comptab)[3] <- 'residuals'
    comptab$Method <- methodnames[i]
    comptab$sample_id <- row.names(comptab)
    
    if(i == 1){
      compdat <- comptab
    }else{
      compdat <- rbind(compdat, comptab)
    }
    
    
  }
  
  row.names(compdat) <- 1:nrow(compdat)
  compdat <- compdat[c('sample_id', 'Prediction', 'True', 'residuals', 'Method')]
  compdat$Method <- factor(compdat$Method, levels = unique(methodnames), 
                           ordered = TRUE)
  
  subtitle <- paste0('(', samplenum, ' samples)')
  
  p <- ggplot2::ggplot(compdat, ggplot2::aes(x=True, y=residuals))
  
  print(
    p + ggplot2::geom_point(ggplot2::aes(color=Method), position='jitter', 
                            alpha=0.5) + 
      ggplot2::xlab('True values') + 
      ggplot2::ylab('Residuals') + 
      ggplot2::ggtitle(title, subtitle = subtitle) + 
      ggplot2::geom_smooth(ggplot2::aes(color=Method), se = FALSE, fullrange = TRUE) + 
      ggplot2::geom_hline(yintercept = 0, color = 'red', size = 1, 
                          linetype = 2) + 
      ggplot2::scale_color_manual(values = scales::hue_pal()(length(
        unique(methodnames)))) + 
      ggplot2::theme_bw()
  )
  
}

#'Draw 2 clock plots to show the true response values and predicted response 
#'  values
#'
#'Draw 2 clock plots to show the true response values and predicted response 
#'  values.
#'
#'@param comptab A matrix or data.frame with the predicted and true response 
#'  values. Each row is a sample, and a column named "Prediction" should be 
#'  used to record the model predicted values, while a column named "True" 
#'  should be used to record the corresponding true values. They should be 
#'  numeric values. In the results generated by the function 
#'  \code{singleselection}, \code{singlebalance} or \code{crosstraining}, the 
#'  slots named "traincomp" and "testcomp" can be used directly as the input 
#'  of this parameter.
#'@param title The title of the plot.
#'@param jitter In some cases, the true values of the samples have a low 
#'  precision, which makes many samples have the same true value and cannot be 
#'  distinguished in the plot. This parameter can be used to introduce some 
#'  random jitters into the true values to distinguish them in the plot.
#'@param colorful Whether the pointers in the clock plots should be colored 
#'  using gradually changed colors to reflect the density of the pointers in 
#'  the plots. If it is set as TRUE and the total pointer number is greater 
#'  than 50, the density color will be used. Default is FALSE.
#'@return Two clock plots with one showing the true sample response values and 
#'  the other showing the predicted response values. In each clock, a pointer 
#'  represents a sample and the scale around the dial is the scale of the true 
#'  or predicted response.
#'@export
clockplot <- function(comptab, 
                      title, 
                      jitterval = TRUE, colorful = FALSE){
  
  comptab <- as.data.frame(comptab, stringsAsFactors = FALSE)
  
  resrange1 <- range(comptab$Prediction)
  resrange2 <- range(comptab$True)
  resrange <- c(floor(min(0, resrange1[1], resrange2[1])), 
                ceiling(max(resrange1[2], resrange2[2])))
  
  if(resrange[2] - max(comptab[,c(1, 2)]) < 0.05){
    resrange[2] <- resrange[2] + 1
  }
  
  vec <- comptab$Prediction
  vec <- round(vec, 2)
  vecdata <- data.frame(Value = vec, stringsAsFactors = FALSE)
  vecdata$yaxis <- 1
  
  colors <- scales::hue_pal()(2)
  
  myColor <- colors[2]
  
  if(colorful == TRUE & nrow(comptab) > 50){
    
    myColor <- densCols(x = vecdata$Value, 
                        colramp = colorRampPalette(rev(rainbow(10, end = 4/6))))
    
  }
  
  vecdata$denscolor <- myColor
  rgbmat <- t(col2rgb(myColor))
  rgbmat <- as.data.frame(rgbmat, stringsAsFactors = FALSE)
  vecdata <- cbind(vecdata, rgbmat)
  vecdata <- vecdata[order(-vecdata$blue, vecdata$red, vecdata$green),]
  vecdata1 <- subset(vecdata, blue >= red)
  vecdata2 <- subset(vecdata, blue < red)
  vecdata2 <- vecdata2[order(-vecdata2$blue, vecdata2$red, -vecdata2$green),]
  vecdata <- rbind(vecdata1, vecdata2)
  row.names(vecdata) <- 1:nrow(vecdata)
  
  vecdata$label <- 'Prediction'
  vecdata1 <- vecdata[c('Value', 'yaxis', 'denscolor', 'label')]
  
  
  
  comptab <- comptab[,c(1, 2)]
  vec <- comptab$True
  if(jitterval == TRUE){
    vec <- jitter(vec, 2)
  }
  vec <- round(vec, 2)
  vecdata <- data.frame(Value = vec, stringsAsFactors = FALSE)
  vecdata$yaxis <- 1
  
  myColor <- colors[1]
  
  if(colorful == TRUE & nrow(comptab) > 50){
    
    myColor <- densCols(x = vecdata$Value, 
                        colramp = colorRampPalette(rev(rainbow(10, end = 4/6))))
    
  }
  
  vecdata$denscolor <- myColor
  rgbmat <- t(col2rgb(myColor))
  rgbmat <- as.data.frame(rgbmat, stringsAsFactors = FALSE)
  vecdata <- cbind(vecdata, rgbmat)
  vecdata <- vecdata[order(-vecdata$blue, vecdata$red, vecdata$green),]
  vecdata3 <- subset(vecdata, blue >= red)
  vecdata2 <- subset(vecdata, blue < red)
  vecdata2 <- vecdata2[order(-vecdata2$blue, vecdata2$red, -vecdata2$green),]
  vecdata <- rbind(vecdata3, vecdata2)
  row.names(vecdata) <- 1:nrow(vecdata)
  
  vecdata$label <- 'True'
  vecdata2 <- vecdata[c('Value', 'yaxis', 'denscolor', 'label')]
  
  rm(vecdata3)
  
  vecdata <- rbind(vecdata1, vecdata2)
  
  vecdata$label <- factor(vecdata$label, levels = c('True', 'Prediction'), 
                          ordered = TRUE)
  
  
  pcc <- cor(comptab$Prediction, comptab$True)
  
  lmfit <- lm(formula = Prediction~True, data = comptab)
  inter <- as.vector(coefficients(lmfit))[1]
  slope <- as.vector(coefficients(lmfit))[2]
  
  if(inter > 0){
    equalsign <- ' + '
    absinter <- signif(inter, 3)
  }else if(inter < 0){
    equalsign <- ' - '
    absinter <- signif(abs(inter), 3)
  }else{
    equalsign <- ''
    absinter <- ''
  }
  
  form <- paste0('y = ', signif(slope, 3), 'x', equalsign, absinter)
  form <- paste0('(', form, ',')
  
  
  lm_eqn <- function(comptab, form){
    m <- lm(Prediction ~ True, comptab)
    eq <- substitute(~~italic(form~R^2~"="~r2), 
                     list(form = form, 
                          r2 = paste0(format(summary(m)$r.squared, digits = 3), 
                                      ")")))
    
    eq <- parse(text = as.character(as.expression(eq)))
    
    return(eq)
  }
  
  
  
  
  p <- ggplot2::ggplot(vecdata, ggplot2::aes(x = Value, y = yaxis))
  
  print(
    p + ggplot2::geom_bar(fill = vecdata$denscolor, position = 'identity', 
                          stat = 'identity', width = 0.05) + 
      ggplot2::scale_x_continuous(limits = resrange, 
                                  n.breaks = 10) + 
      ggplot2::scale_y_continuous(limits = c(0, 1)) + 
      ggplot2::xlab('') + 
      ggplot2::theme_bw() + 
      ggplot2::ggtitle(paste0('Clocks on ', title), 
                       subtitle = lm_eqn(comptab = comptab, form = form)) + 
      
      ggplot2::theme(panel.grid.major.y = ggplot2::element_line(color = 
                                                                  scales::hue_pal()(5))) + 
      ggplot2::theme(axis.title = ggplot2::element_blank(), 
                     axis.text.y = ggplot2::element_blank(), 
                     axis.ticks.y = ggplot2::element_blank(), 
                     axis.text.x = ggplot2::element_text(size = 15)) + 
      ggplot2::coord_polar() + 
      ggplot2::facet_wrap(~label)
    
  )
  
}





localrplot <- function(comptab, 
                       featurenum = NULL, 
                       title, 
                       stepsize = NULL, 
                       averagepre = FALSE, 
                       plotting = TRUE){
  
  samplenum <- nrow(comptab)
  
  comptab <- as.data.frame(comptab)
  
  comptab <- comptab[order(comptab$True, comptab$Prediction),]
  
  trues <- comptab$True
  trues <- round(trues)
  comptab$roundTrue <- trues
  
  unitrues <- unique(trues)
  unitrues <- unitrues[order(unitrues)]
  
  if(averagepre == TRUE){
    
    submean <- function(sub){
      
      subline <- colMeans(sub)
      subline <- as.matrix(subline)
      subline <- t(subline)
      row.names(subline) <- 1:nrow(subline)
      
      return(subline)
      
    }
    
    comptab <- plyr::ddply(.data = comptab, .variables = c('roundTrue'), 
                           .fun = submean)
  }
  
  
  maketrues <- function(seedtrues, oritrues){
    
    oristart <- min(oritrues)
    
    step <- min(diff(seedtrues))
    
    seedend <- max(seedtrues)
    
    newtrues <- seq(from = oristart, to = seedend, by = step)
    newtrues <- c(newtrues, seedtrues)
    newtrues <- unique(newtrues)
    newtrues <- newtrues[order(newtrues)]
    
    if(sum(!(oritrues %in% newtrues)) == 0 & length(unique(diff(newtrues))) == 1){
      return(newtrues)
    }else{
      maketrues(seedtrues = newtrues, oritrues = oritrues)
    }
    
  }
  
  completetrues <- maketrues(seedtrues = unitrues, oritrues = unitrues)
  
  start <- 1
  end <- length(completetrues)
  
  if(is.null(stepsize)){
    
    stepsize <- max(3*min(diff(completetrues)), min(diff(unitrues)), 
                    ceiling(diff(c(min(completetrues), max(completetrues)))/10))
    
  }
  
  
  subpccs <- c()
  truemeans <- c()
  for(i in start:end){
    
    inf <- completetrues[i]
    sup <- inf + stepsize
    
    sub <- subset(comptab, roundTrue >= inf & roundTrue <= sup)
    if(nrow(sub) == 0){
      next()
    }
    
    if(min(sub$roundTrue) == max(sub$roundTrue)){
      next()
    }
    
    
    subpcc <- cor(sub$Prediction, sub$True)
    
    truemean <- mean(sub$True)
    
    subpccs <- c(subpccs, subpcc)
    truemeans <- c(truemeans, truemean)
    
  }
  
  subrsquares <- subpccs^2
  
  rtab <- data.frame(localmean = truemeans, 
                     localr = subrsquares, 
                     stringsAsFactors = FALSE)
  
  
  if(plotting == TRUE){
    
    if(!is.null(featurenum)){
      subtitle <- paste0('(', featurenum, ' features on ', samplenum, 
                         ' samples, stepsize = ', stepsize, ')')
    }else{
      subtitle <- paste0('(', samplenum, 
                         ' samples, stepsize = ', stepsize, ')')
      
    }
    
    myColor <- rep('blue', nrow(rtab))
    
    rtab$denscolor <- myColor
    
    p <- ggplot2::ggplot(rtab, ggplot2::aes(x=localmean, y=localr))
    
    print(
      p + ggplot2::geom_point(color=rtab$denscolor, position='jitter') + 
        ggplot2::xlab('Local true value means') + 
        ggplot2::ylab('Local R squares') + 
        ggplot2::ggtitle(title, subtitle = subtitle) + 
        ggplot2::geom_smooth(se = FALSE, fullrange = TRUE) + 
        ggplot2::geom_hline(yintercept = 0.5, color = 'red', size = 1, 
                            linetype = 2) + 
        ggplot2::theme_bw()
    )
    
  }
  
  rtab <- rtab[c('localmean', 'localr')]
  return(rtab)
  
}

localrcomp <- function(comptabs, 
                       title, 
                       methodnames, 
                       stepsize = NULL, 
                       averagepre = FALSE){
  
  if(length(comptabs) <= 1){
    return(NULL)
  }
  
  for(i in 1:(length(comptabs) - 1)){
    
    comptab1 <- comptabs[[i]]
    comptab2 <- comptabs[[i + 1]]
    comp <- sum(row.names(comptab1) != row.names(comptab2))
    if(i == 1){
      comps <- comp
    }else{
      comps <- comps + comp
    }
    
  }
  
  if(comps >= 1){
    return(NULL)
  }
  
  
  samplenum <- nrow(comptab1)
  
  for(i in 1:length(comptabs)){
    
    comptab <- as.data.frame(comptabs[[i]])
    
    comptab <- comptab[order(comptab$True, comptab$Prediction),]
    
    if(i == 1){
      
      trues <- comptab$True
      trues <- round(trues)
      
      
      unitrues <- unique(trues)
      
      maketrues <- function(seedtrues, oritrues){
        
        oristart <- min(oritrues)
        
        step <- min(diff(seedtrues))
        
        seedend <- max(seedtrues)
        
        newtrues <- seq(from = oristart, to = seedend, by = step)
        newtrues <- c(newtrues, seedtrues)
        newtrues <- unique(newtrues)
        newtrues <- newtrues[order(newtrues)]
        
        if(sum(!(oritrues %in% newtrues)) == 0 & length(unique(diff(newtrues))) == 1){
          return(newtrues)
        }else{
          maketrues(seedtrues = newtrues, oritrues = oritrues)
        }
        
      }
      
      completetrues <- maketrues(seedtrues = unitrues, oritrues = unitrues)
      
      start <- 1
      end <- length(completetrues)
      
      if(is.null(stepsize)){
        
        stepsize <- max(3*min(diff(completetrues)), min(diff(unitrues)), 
                        ceiling(diff(c(min(completetrues), max(completetrues)))/10))
        
      }
      
    }
    
    comptab$roundTrue <- trues
    
    if(averagepre == TRUE){
      
      submean <- function(sub){
        
        subline <- colMeans(sub)
        subline <- as.matrix(subline)
        subline <- t(subline)
        row.names(subline) <- 1:nrow(subline)
        
        return(subline)
        
      }
      
      comptab <- plyr::ddply(.data = comptab, .variables = c('roundTrue'), 
                             .fun = submean)
    }
    
    subpccs <- c()
    truemeans <- c()
    for(j in start:end){
      
      inf <- completetrues[j]
      sup <- inf + stepsize
      
      sub <- subset(comptab, roundTrue >= inf & roundTrue <= sup)
      if(nrow(sub) == 0){
        next()
      }
      
      if(min(sub$roundTrue) == max(sub$roundTrue)){
        next()
      }
      
      
      subpcc <- cor(sub$Prediction, sub$True)
      
      truemean <- mean(sub$True)
      
      subpccs <- c(subpccs, subpcc)
      truemeans <- c(truemeans, truemean)
      
    }
    
    subrsquares <- subpccs^2
    
    rtab <- data.frame(localmean = truemeans, 
                       localr = subrsquares, 
                       stringsAsFactors = FALSE)
    
    rtab$Method <- methodnames[i]
    rtab$sample_id <- row.names(rtab)
    
    if(i == 1){
      rdat <- rtab
    }else{
      rdat <- rbind(rdat, rtab)
    }
    
    
  }
  
  row.names(rdat) <- 1:nrow(rdat)
  rdat <- rdat[c('localmean', 'localr', 'Method')]
  rdat$Method <- factor(rdat$Method, levels = methodnames, ordered = TRUE)
  
  subtitle <- paste0('(', samplenum, ' samples, stepsize = ', stepsize, ')')
  
  p <- ggplot2::ggplot(rdat, ggplot2::aes(x=localmean, y=localr))
  
  print(
    p + ggplot2::geom_point(ggplot2::aes(color=Method), 
                            alpha=0.5) + 
      ggplot2::xlab('Local true value means') + 
      ggplot2::ylab('Local R squares') + 
      ggplot2::ggtitle(title, subtitle = subtitle) + 
      ggplot2::geom_smooth(ggplot2::aes(color=Method), se = FALSE, fullrange = TRUE) + 
      ggplot2::geom_hline(yintercept = 0, color = 'red', size = 1, 
                          linetype = 2) + 
      ggplot2::scale_color_manual(values = scales::hue_pal()(length(methodnames))) + 
      ggplot2::theme_bw()
  )
  
}



