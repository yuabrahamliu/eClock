
#Probe annotation####

#'Extract features selected
#'
#'Extract features selected from the models.
#'
#'@param res Results generated by the function \code{singleselection}, 
#'  \code{singlebalance}, or \code{crosstraining}.
#'@return A data.frame with two columns. One is named "Probe" containing the 
#'  features extracted from the single model trained by the function 
#'  \code{singleselection} or \code{singlebalance}, or from all the models 
#'  trained by the function \code{crosstraining}. The other is a column named 
#'  "Coeffsum", and for each feature, its value is the sum of its regression 
#'  coefficients in all the models contained in \code{res}.
#'@export
extractprobes <- function(res){
  
  if(!('plyr' %in% installed.packages()[,'Package'])){
    cat('Package plyr is needed to run this function\n')
    return(NULL)
  }
  
  if('modelcoeffs' %in% names(res)){
    
    probesub <- res$modelcoeffs
    probesub  <- probesub[complete.cases(probesub),]
    probesub <- as.matrix(probesub)
    probesub <- probesub[rowSums(probesub) != 0,]
    probesub <- as.matrix(probesub)
    probesub <- probesub[row.names(probesub) != '(Intercept)',1:ncol(probesub)]
    probesub <- as.matrix(probesub)
    
    probesub <- rowMeans(probesub)
    probesub <- as.matrix(probesub)
    Probes <- row.names(probesub)
    
    probesub <- as.data.frame(probesub, stringsAsFactors = FALSE)
    probesub$Probe <- Probes
    row.names(probesub) <- Probes
    
  }else if('modellist' %in% names(res)){
    
    if(length(res$modellist) >= 1){
      
      for(i in 1:length(res$modellist)){
        
        probes <- res$modellist[[i]]$modelcoeffs
        probesub  <- probesub[complete.cases(probesub),]
        probesub <- as.matrix(probesub)
        probes <- probes[rowSums(probes) != 0,]
        probes <- as.matrix(probes)
        probes <- probes[row.names(probes) != '(Intercept)',1:ncol(probes)]
        probes <- as.matrix(probes)
        
        probes <- rowMeans(probes)
        probes <- as.matrix(probes)
        Probes <- row.names(probesub)
        
        probes <- as.data.frame(probes, stringsAsFactors = FALSE)
        probesub$Probe <- Probes
        row.names(probesub) <- Probes
        
        if(i == 1){
          probesub <- probes
        }else{
          probesub <- rbind(probesub, probes)
        }
        
      }
      
    }else{
      
      return(NULL)
      
    }
    
  }else{
    return(NULL)
  }
  
  row.names(probesub) <- 1:nrow(probesub)
  
  calsum <- function(block){
    
    probe <- unique(block$probe)
    subblock <- block[-grep('Probe', colnames(probesub))]
    subsum <- colSums(subblock)
    submatrix <- data.frame(subsum)
    submatrix <- t(submatrix)
    row.names(submatrix) <- probe
    submatrix <- as.data.frame(submatrix)
    return(submatrix)
    
  }
  
  probesub <- plyr::ddply(.data = probesub, .variables = c('Probe'), 
                          .fun = calsum)
  names(probesub)[2] <- 'Coeffsum'
  probesub <- probesub[order(-probesub$Coeffsum),]
  row.names(probesub) <- 1:nrow(probesub)
  
  return(probesub)
  
}

#'Annotate the Illumina methylation probes
#'
#'Annotate the Illumina methylation probes
#'
#'@param platform The platform of the probes need to be annotated. Can be set 
#'  as 27 (for 27k platform), 450 (for 450k platform), or 850 (for EPIC 
#'  platform). Default is 450.
#'@param finalprobes The names of the probes need to be annotated.
#'@return A data.frame with the probe annotation information, including the 
#'  genomic loci of the probes and their related CpG islands and genes.
#'@export
probeannotation <- function(platform = 450, 
                            finalprobes){
  
  if(platform == 27){
    annotation <- 'ilmn12.hg19'
    array <- 'IlluminaHumanMethylation27k'
  }else if(platform == 450){
    annotation <- 'ilmn12.hg19'
    array <- 'IlluminaHumanMethylation450k'
  }else if(platform == 850){
    annotation <- 'ilm10b4.hg19'
    array <- 'IlluminaHumanMethylationEPIC'
  }else{
    cat('The parameter `platform` should be provided a value from 27, 450, and 850\n')
    return(NULL)
  }
  
  annopackage <- paste0(array, 'anno.', annotation)
  
  if(!(annopackage %in% installed.packages()[,'Package'])){
    cat(paste0('Package ', annopackage, ' is needed to run this function\n'))
    return(NULL)
  }
  
  if(!('AnnotationDbi' %in% installed.packages()[,'Package'])){
    cat('Package AnnotationDbi is needed to run this function\n')
    return(NULL)
  }
  
  if(!('org.Hs.eg.db' %in% installed.packages()[,'Package'])){
    cat(paste0('Package org.Hs.eg.db is needed to run this function\n'))
    return(NULL)
  }
  
  
  if(platform == 27){
    
    probeinfo <- IlluminaHumanMethylation27kanno.ilmn12.hg19::Other
    islandsinfo <- probeinfo[c("CPG_ISLAND_LOCATIONS", "CPG_ISLAND")]
    locinfo <- IlluminaHumanMethylation27kanno.ilmn12.hg19::Locations
    
    selectedcol <- c("Symbol", "Distance_to_TSS")
    genecol <- 'Symbol'
    featurecol <- 'Distance_to_TSS'
    islandcol <- 'CPG_ISLAND'
  }else if(platform == 450){
    
    probeinfo <- IlluminaHumanMethylation450kanno.ilmn12.hg19::Other
    islandsinfo <- IlluminaHumanMethylation450kanno.ilmn12.hg19::Islands.UCSC
    locinfo <- IlluminaHumanMethylation450kanno.ilmn12.hg19::Locations
    
    selectedcol <- c("UCSC_RefGene_Name", "UCSC_RefGene_Group")
    genecol <- 'UCSC_RefGene_Name'
    featurecol <- 'UCSC_RefGene_Group'
    islandcol <- 'Relation_to_Island'
  }else if(platform == 850){
    
    probeinfo <- IlluminaHumanMethylationEPICanno.ilm10b4.hg19::Other
    islandsinfo <- IlluminaHumanMethylationEPICanno.ilm10b4.hg19::Islands.UCSC
    locinfo <- IlluminaHumanMethylationEPICanno.ilm10b4.hg19::Locations
    
    selectedcol <- c("UCSC_RefGene_Name", "UCSC_RefGene_Group")
    genecol <- 'UCSC_RefGene_Name'
    featurecol <- 'UCSC_RefGene_Group'
    islandcol <- 'Relation_to_Island'
  }
  
  finalprobes <- finalprobes[finalprobes %in% row.names(probeinfo)]
  if(length(finalprobes) == 0){
    return(NULL)
  }
  
  
  probeinfo <- probeinfo[finalprobes,]
  probeinfodata <- as.data.frame(probeinfo)
  
  probeinfodata <- probeinfodata[selectedcol]
  
  islandsinfo <- islandsinfo[finalprobes,]
  islandsinfodata <- as.data.frame(islandsinfo)
  
  locinfo <- locinfo[finalprobes,]
  locinfo <- as.data.frame(locinfo)
  
  probeinfodata <- cbind(locinfo, probeinfodata, islandsinfodata)
  probeinfodata$Probe <- row.names(probeinfodata)
  row.names(probeinfodata) <- 1:nrow(probeinfodata)
  
  if(platform == 27){
    probeinfodata$ENTREZID <- probeinfo$Gene_ID
  }
  
  
  orgnizeprobeinfo <- function(colvec){
    parseelement <- function(element){
      elementlist <- unlist(strsplit(x = element, split = ';', fixed = TRUE))
      
      if(length(elementlist) == 0){
        elementlist <- ''
      }
      
      return(elementlist)
    }
    collist <- lapply(colvec, parseelement)
    return(collist)
  }
  
  genenamelist <- orgnizeprobeinfo(colvec = probeinfodata[,genecol])
  featurelist <- orgnizeprobeinfo(colvec = probeinfodata[,featurecol])
  poslist <- orgnizeprobeinfo(colvec = probeinfodata[,islandcol])
  
  genenamelistlens <- unlist(lapply(X = genenamelist, FUN = length))
  featurelistlens <- unlist(lapply(X = featurelist, FUN = length))
  poslistlens <- unlist(lapply(X = poslist, FUN = length))
  
  if(sum(genenamelistlens != 1) == 0 & platform == 27){
    probeinfodata$ENTREZID <- gsub(pattern = 'GeneID:', replacement = '', 
                                   x = probeinfodata$ENTREZID, fixed = TRUE)
  }
  
  if(sum(genenamelistlens == 0) == 0){
    
    datnames <- colnames(probeinfodata)
    
    chrvec <- rep(probeinfodata[,1], times = genenamelistlens)
    locvec <- rep(probeinfodata[,2], times = genenamelistlens)
    strandvec <- rep(probeinfodata[,3], times = genenamelistlens)
    
    genenamevec <- unlist(genenamelist)
    featurevec <- unlist(featurelist)
    
    islandvec <- rep(probeinfodata[,6], times = genenamelistlens)
    posvec <- rep(probeinfodata[,7], times = genenamelistlens)
    probevec <- rep(probeinfodata[,8], times = genenamelistlens)
    
    if(platform == 27){
      
      geneidlist <- orgnizeprobeinfo(colvec = probeinfodata$ENTREZID)
      geneidvec <- unlist(geneidlist)
      geneidvec <- gsub(pattern = 'GeneID:', replacement = '', 
                        x = geneidvec, fixed = TRUE)
      
      probeinfodata <- tryCatch({
        data.frame(chrvec, locvec, strandvec, 
                   genenamevec, 
                   featurevec, 
                   islandvec, posvec, probevec, 
                   geneidvec, 
                   stringsAsFactors = FALSE)
      }, error = function(err){
        probeinfodata
      })
      
      names(probeinfodata) <- datnames[1:ncol(probeinfodata)]
      
      probeinfodata <- unique(probeinfodata)
      
    }else{
      
      unigeneidvec <- AnnotationDbi::select(x = org.Hs.eg.db::org.Hs.eg.db, 
                                            keys = unique(genenamevec), 
                                            columns = 'ENTREZID', 
                                            keytype = 'SYMBOL')
      names(unigeneidvec)[1] <- selectedcol[1]
      
      probeinfodata <- tryCatch({
        data.frame(chrvec, locvec, strandvec, 
                   genenamevec, 
                   featurevec, 
                   islandvec, posvec, probevec, 
                   stringsAsFactors = FALSE)
      }, error = function(err){
        probeinfodata
      })
      
      names(probeinfodata) <- datnames[1:ncol(probeinfodata)]
      probeinfodata <- unique(probeinfodata)
      
      if(sum(!(unique(probeinfodata[,selectedcol[1]]) %in% 
               unigeneidvec[,selectedcol[1]])) == 0){
        
        probeinfodata <- merge(probeinfodata, unigeneidvec, 
                               by = selectedcol[1], 
                               sort = FALSE)
        
      }
      
      probeinfodata <- unique(probeinfodata)
      
    }
    
    if('Distance_to_TSS' %in% datnames){
      
      probeinfodata$Distance_to_TSS <- as.integer(probeinfodata$Distance_to_TSS)
      
    }
    
    if('CPG_ISLAND' %in% datnames){
      
      probeinfodata$CPG_ISLAND <- as.logical(probeinfodata$CPG_ISLAND)
      
    }
    
  }
  
  if(platform == 27){
    
    resnames <- c('Probe', 'chr', 'pos', 'strand', 
                  'CPG_ISLAND_LOCATIONS', 'CPG_ISLAND', 
                  'Symbol', 'ENTREZID', 'Distance_to_TSS')
    
  }else{
    
    resnames <- c('Probe', 'chr', 'pos', 'strand', 
                  'Islands_Name', 'Relation_to_Island', 
                  'UCSC_RefGene_Name', 'ENTREZID', 'UCSC_RefGene_Group')
    
  }
  
  probeinfodata <- probeinfodata[,resnames[unique(c(1:7, 
                                                    (ncol(probeinfodata) - 1), 9))]]
  
  row.names(probeinfodata) <- 1:nrow(probeinfodata)
  
  
  return(probeinfodata)
  
}

#Methylation gene summary###

summaryfeature <- function(dat, featurecolidx){
  
  if(!('plyr' %in% installed.packages()[,'Package'])){
    cat('Package plyr is needed to run this function\n')
    return(NULL)
  }
  
  calmean <- function(block){
    gene <- unique(block$gene)
    subblock <- block[-1]
    submean <- colMeans(subblock)
    submatrix <- data.frame(submean)
    submatrix <- t(submatrix)
    row.names(submatrix) <- gene
    submatrix <- as.data.frame(submatrix)
    return(submatrix)
    
  }
  
  features <- dat[,featurecolidx]
  featurefreqs <- table(features)
  unifeatures <- names(featurefreqs[featurefreqs == 1])
  mulfeatures <- names(featurefreqs[featurefreqs > 1])
  
  unipart <- dat[dat[,featurecolidx] %in% unifeatures,]
  mulpart <- dat[dat[,featurecolidx] %in% mulfeatures,]
  
  mulpart <- plyr::ddply(.data = mulpart, 
                         .variables = c(names(dat)[featurecolidx]), 
                         .fun = calmean)
  
  row.names(mulpart) <- mulpart[,featurecolidx]
  mulpart <- mulpart[-featurecolidx]
  
  row.names(unipart) <- unipart[,featurecolidx]
  unipart <- unipart[-featurecolidx]
  
  finaldat <- rbind(unipart, mulpart)
  finaldat <- as.matrix(finaldat)
  
  return(finaldat)
  
}

#'Summarize the methylation beta values of probes to genes
#'
#'Summarize the methylation beta values of probes to genes by averaging the 
#'  probes located closely to the TSS of a gene.
#'
#'@param betadat A matrix recording the beta values of methylation probes for 
#'  samples. Each column represents one sample and each row represents one 
#'  probe. The row names are the probe names while the column names should be 
#'  sample IDs.
#'@param platform The platform of the probes. Can be set as 27 (for 27k 
#'  platform), 450 (for 450k platform), or 850 (for EPIC platform). Default is 
#'  450.
#'@param range27k A single positive number or a vector with two positive 
#'  numbers. If the data is based on 27k platform, this parameter is needed to 
#'  define which probes could be considered as related to a specific gene, 
#'  and only the ones with a distance to the TSS of a gene less than the 
#'  maximum value and greater than the minimum value of \code{range27k} will 
#'  be considered as related to the gene, and the beta values of these probes 
#'  will be averaged to get the gene beta value. If it is a single number, the 
#'  probes with a distance less than this number and greater than 0 will be 
#'  attributed to a gene. Default is 200.
#'@param group450k850k A vector or single string. If the data is based on 450k 
#'  or EPIC platform, this parameter is needed to define which probes could be 
#'  considered as related to a specific gene. Only the ones located in the 
#'  gene regions included in this parameter will be considered as belong to 
#'  the gene. The value of this parameter can be selected from "TSS200", 
#'  "TSS1500", "1stExon", "5'UTR", '3'UTR", and "Body". The default value is 
#'  the vector c("TSS200", "TSS1500", "1stExon"), which means probes within 
#'  these 3 regions of a gene will be attributed to the gene and their beta 
#'  values will be averaged to get the gene beta value.
#'@param includemultimatch Some probes can be attributed to more than one 
#'  gene. If this parameter is TRUE, these probes will be involved into the 
#'  beta value calculation for all their related genes. Otherwise, these 
#'  probes will be discarded, so that the beta values of all the genes are 
#'  averaged only from their uniquely related probes. Default is TRUE.
#'@return A matrix recording the summarized gene beta values for samples.
#'@export
probetogene <- function(betadat, 
                        platform = 450, 
                        range27k = 200, 
                        group450k850k = c('TSS200', 'TSS1500', '1stExon'), 
                        includemultimatch = TRUE){
  
  if(min(betadat) < 0 | max(betadat) > 1){
    
    cat('Need methylation beta value to run this function and values < 0 or > 1 cannot be used\n')
    return(NULL)
    
  }
  
  beforeprobes <- row.names(betadat)
  
  tssinfo <- probeannotation(platform = platform, finalprobes = beforeprobes)
  
  if(is.null(tssinfo)){
    return(NULL)
  }
  
  if(platform == 27){
    if(length(range27k) == 1){
      range27k <- c(0, range27k)
    }else{
      range27k <- c(min(range27k), max(range27k))
    }
    
    tssinfor <- tssinfo[!is.na(tssinfo$Distance_to_TSS),]
    tssinfor <- tssinfor[(tssinfor$Distance_to_TSS >= as.numeric(min(range27k)) & 
                            tssinfor$Distance_to_TSS < as.numeric(max(range27k))),]
    tssinfor <- tssinfor[,c('Probe', 
                            'Symbol', 'ENTREZID')]
  }else{
    tssinfor <- tssinfo[tssinfo$UCSC_RefGene_Group %in% group450k850k,]
    tssinfor <- tssinfor[,c('Probe', 
                            'UCSC_RefGene_Name', 'ENTREZID')]
  }
  
  tssinfor <- unique(tssinfor)
  
  probes <- tssinfor$Probe
  
  if(includemultimatch == FALSE){
    
    probes <- probes[probes %in% names(table(probes)[table(probes) == 1])]
    
  }
  
  tssinfor <- subset(tssinfor, Probe %in% probes)
  
  tssinfor <- tssinfor[order(tssinfor[,2], tssinfor[,3]),]
  row.names(tssinfor) <- 1:nrow(tssinfor)
  
  
  tssinfor$genename <- paste0(tssinfor[,2], '::', tssinfor[,3])
  tssinfor$genename <- gsub(pattern = '^::', replacement = '', 
                            x = tssinfor$genename)
  tssinfor$genename <- gsub(pattern = '::$', replacement = '', 
                            x = tssinfor$genename)
  tssinfor$genename <- gsub(pattern = '^NA::', replacement = '', 
                            x = tssinfor$genename)
  tssinfor$genename <- gsub(pattern = '::NA$', replacement = '', 
                            x = tssinfor$genename)
  
  
  betadat <- betadat[tssinfor$Probe, , drop = FALSE]
  betadat <- as.data.frame(betadat, stringsAsFactors = FALSE)
  betadat$genename <- tssinfor$genename
  betadat <- betadat[,c(ncol(betadat), 1:(ncol(betadat) - 1))]
  
  betadat <- summaryfeature(dat = betadat, featurecolidx = 1)
  
  if(is.null(betadat)){
    return(NULL)
  }
  
  genenames <- row.names(betadat)
  geneorders <- order(genenames)
  betadat <- betadat[geneorders, , drop = FALSE]
  
  return(betadat)
  
}

#'Annotate genes
#'
#'Annotate genes coordinates and functions
#'
#'@param genesymbols A vector containing the symbols of the genes need to be 
#'  annotated.
#'@param geneentrezs A vector containing the ENTREZ IDs of the genes need to 
#'  be annotated. If \code{genesymbols} is NULL, this value will be used, and 
#'  if this value is also NULL, the function will turn NULL.
#'@return A data.frame with the gene annotation information, including the 
#'  genomic coordinates of the genes and their function descriptions.
#'@export
geneannotation <- function(genesymbols = NULL, 
                           geneentrezs = NULL){
  
  
  summaryannotation <- get('summaryannotation')
  
  
  if(!is.null(genesymbols)){
    
    genesymbols <- genesymbols[!is.na(genesymbols)]
    genesymbols <- toupper(genesymbols)
    
    totalprobegeneannotation <- subset(summaryannotation, 
                                       SYMBOL %in% genesymbols | 
                                         preferred_name %in% genesymbols)
    
    part1 <- subset(totalprobegeneannotation, 
                    SYMBOL %in% genesymbols)
    part1$input <- part1$SYMBOL
    
    part2 <- subset(totalprobegeneannotation, 
                    !(SYMBOL %in% genesymbols))
    part2$input <- part2$preferred_name
    
    totalprobegeneannotation <- rbind(part1, part2)
    totalprobegeneannotation <- unique(totalprobegeneannotation)
    
    
    others <- genesymbols[!(genesymbols %in% 
                              c(totalprobegeneannotation$SYMBOL, 
                                totalprobegeneannotation$preferred_name))]
    
    
  }else if(!is.null(geneentrezs)){
    
    geneentrezs <- as.character(geneentrezs)
    geneentrezs <- geneentrezs[!is.na(geneentrezs)]
    totalprobegeneannotation <- subset(summaryannotation, 
                                       ENTREZID %in% geneentrezs)
    totalprobegeneannotation$input <- totalprobegeneannotation$ENTREZID
    totalprobegeneannotation <- unique(totalprobegeneannotation)
    
    others <- geneentrezs[!(geneentrezs %in% totalprobegeneannotation$ENTREZID)]
    
  }else{
    
    return(NULL)
  }
  
  if(length(others) > 0){
    others <- data.frame(ENTREZID = NA, 
                         SYMBOL = NA, 
                         chr = NA, 
                         start = NA, 
                         end = NA, 
                         strand = NA, 
                         preferred_name = NA, 
                         UniProt = NA, 
                         UniProt.name = NA, 
                         protein.size = NA, 
                         annotation = NA, 
                         input = others, 
                         stringsAsFactors = FALSE)
    totalprobegeneannotation <- rbind(totalprobegeneannotation, others)
    
  }
  
  
  
  totalprobegeneannotation <- unique(totalprobegeneannotation)
  totalprobegeneannotation <- totalprobegeneannotation[
    c('input', 'ENTREZID', 'SYMBOL', 'chr', 'start', 'end', 'strand', 
      'preferred_name', 'UniProt', 'UniProt.name', 'protein.size', 'annotation')
  ]
  
  row.names(totalprobegeneannotation) <- 1:nrow(totalprobegeneannotation)
  
  
  return(totalprobegeneannotation)
  
  
}


#Methylation DMR summary###

coverredtss <- function(fragments, tssradius = NULL, ignorestrand = TRUE){
  
  if(!('GenomicFeatures' %in% installed.packages()[,'Package'])){
    cat('Package GenomicFeatures is needed to run this function\n')
    return(NULL)
  }
  
  if(!('TxDb.Hsapiens.UCSC.hg19.knownGene' %in% installed.packages()[,'Package'])){
    cat('Package TxDb.Hsapiens.UCSC.hg19.knownGene is needed to run this function\n')
    return(NULL)
  }
  
  if(!('IRanges' %in% installed.packages()[,'Package'])){
    cat('Package IRanges is needed to run this function\n')
    return(NULL)
  }
  
  if(!('GenomicRanges' %in% installed.packages()[,'Package'])){
    cat('Package GenomicRanges is needed to run this function\n')
    return(NULL)
  }
  
  if(!('AnnotationDbi' %in% installed.packages()[,'Package'])){
    cat('Package AnnotationDbi is needed to run this function\n')
    return(NULL)
  }
  
  if(!('org.Hs.eg.db' %in% installed.packages()[,'Package'])){
    cat('Package org.Hs.eg.db is needed to run this function\n')
    return(NULL)
  }
  
  genecoords <- suppressMessages(
    GenomicFeatures::genes(TxDb.Hsapiens.UCSC.hg19.knownGene::TxDb.Hsapiens.UCSC.hg19.knownGene))
  generanges <- genecoords@ranges
  
  geneids <- genecoords$gene_id
  geneseqs <- genecoords@seqnames
  genestrands <- genecoords@strand
  
  genetssp <- generanges@start[as.vector(genestrands == '+')]
  genetssm <- generanges@start[as.vector(genestrands == '-')] + 
    generanges@width[as.vector(genestrands == '-')] - 1
  
  tss <- rep(0, length(genecoords))
  tss[as.vector(genestrands == '+')] <- genetssp
  tss[as.vector(genestrands == '-')] <- genetssm
  
  tssranges <- IRanges::IRanges(start = tss, width = 1)
  tsscoords <- GenomicRanges::GRanges(seqnames = geneseqs, 
                                      ranges = tssranges, 
                                      strand = genestrands, 
                                      gene_id = geneids)
  
  
  fragchrs <- gsub(pattern = ':.*$', replacement = '', x = fragments)
  fragcoords <- gsub(pattern = '^chr.*:', replacement = '', x = fragments)
  fragstarts <- gsub(pattern = '-.*$', replacement = '', x = fragcoords)
  fragends <- gsub(pattern = '^.*-', replacement = '', x = fragcoords)
  fragstarts <- as.numeric(fragstarts)
  fragends <-as.numeric(fragends)
  
  fragranges <- IRanges::IRanges(start = fragstarts, end = fragends)
  fragranges <- GenomicRanges::GRanges(seqnames = fragchrs, 
                                       ranges = fragranges, strand = '*', 
                                       fragmentname = fragments)
  
  dis <- GenomicRanges::distanceToNearest(x = tsscoords, 
                                          subject = fragranges, 
                                          ignore.strand = ignorestrand)
  disvec <- dis@elementMetadata$distance
  
  rangeinfo <- fragranges[dis@to,]
  geneinfo <- genecoords[dis@from,]
  rangeinfo <- as.data.frame(rangeinfo)
  names(geneinfo) <- 1:length(geneinfo)
  geneinfo <- as.data.frame(geneinfo)
  names(rangeinfo) <- paste('range', names(rangeinfo), sep = '_')
  names(geneinfo) <- paste('gene', names(geneinfo), sep = '_')
  overlap <- cbind(rangeinfo, geneinfo)
  overlap$tssdistance <- disvec
  overlap <- unique(overlap)
  
  
  genesyms <- AnnotationDbi::select(x = org.Hs.eg.db::org.Hs.eg.db, 
                                    keys = overlap$gene_gene_id, 
                                    columns = 'SYMBOL', 
                                    keytype = 'ENTREZID')
  overlap <- cbind(overlap, genesyms)
  
  generes <- data.frame(frag = overlap$range_fragmentname, 
                        seqnames = overlap$gene_seqnames, 
                        start = overlap$gene_start, 
                        end = overlap$gene_end, 
                        width = overlap$gene_width, 
                        strand = overlap$gene_strand, 
                        geneid = overlap$ENTREZID, 
                        genename = overlap$SYMBOL, 
                        TSSdistance = overlap$tssdistance, 
                        stringsAsFactors = FALSE)
  
  if(!is.null(tssradius)){
    generes <- subset(generes, TSSdistance <= tssradius)
  }
  
  return(generes)
}

#'Summarize the beta values of probes to DNA methylation regions (DMRs)
#'
#'Cluster the probes into DNA methylation regions (DMRs) and calculate the 
#'  beta values of the DMRs via averaging the probe beta values within it.
#'
#'@param betadat A matrix recording the beta values of methylation probes for 
#'  samples. Each column represents one sample and each row represents one 
#'  probe. The row names are the probe names while the column names should be 
#'  sample IDs.
#'@param platform The platform of the probes. Can be set as 27 (for 27k 
#'  platform), 450 (for 450k platform), or 850 (for EPIC platform). Default is 
#'  450.
#'@param maxgap An integer indicating the cutoff of probe-probe distance when 
#'  clustering the probes into DNA methylation regions (DMRs). If the distance 
#'  between 2 neighbor probes is less than this cutoff, they will be clustered 
#'  into the same DMR. Default is 300.
#'@param TSSradius An integer defining the TSS region that will be considered 
#'  when mapping the genes to DMRs. If an DMR overlaps with a gene region from 
#'  \code{TSSradius} bp upstream to \code{TSSradius} bp downstream of the TSS, 
#'  this gene will be attributed to this DMR. In case when one gene region 
#'  overlaps with more than one DMR, it will be attributed to the DMR with the 
#'  closest distance to it, so that the genes covered by the DMRs can be 
#'  annotated. Default value is 1500.
#'@return A list with 3 slots. The slot named "betadat" is a matrix recording 
#'  the DMR beta values of samples. The slot named "dmrprobemapping" is a 
#'  data.frame recording the probes covered by each DMR and the coordinates 
#'  and other information of the DMRs and probes. The slot "dmrgenemapping" is 
#'  a data.frame recording the genes whose TSS regions are covered by each 
#'  DMR.
#'@export
probetodmr <- function(betadat, 
                       platform = 450, 
                       maxgap = 300, 
                       TSSradius = 1500, 
                       ignorestrand = TRUE){
  
  if(platform == 27){
    annotation <- 'ilmn12.hg19'
    array <- 'IlluminaHumanMethylation27k'
  }else if(platform == 450){
    annotation <- 'ilmn12.hg19'
    array <- 'IlluminaHumanMethylation450k'
  }else if(platform == 850){
    annotation <- 'ilm10b4.hg19'
    array <- 'IlluminaHumanMethylationEPIC'
  }else{
    cat('The parameter `platform` should be provided a value from 27, 450, and 850\n')
    return(NULL)
  }
  
  annopackage <- paste0(array, 'anno.', annotation)
  
  if(!(annopackage %in% installed.packages()[,'Package'])){
    cat(paste0('Package ', annopackage, ' is needed to run this function\n'))
    return(NULL)
  }
  
  if(!('bumphunter' %in% installed.packages()[,'Package'])){
    cat('Package bumphunter is needed to run this function\n')
    return(NULL)
  }
  
  if(min(betadat) < 0 | max(betadat) > 1){
    
    cat('Need methylation beta value to run this function and values < 0 or > 1 cannot be used\n')
    return(NULL)
  }
    
  betas[betas == 0] <- min(betas[betas > 0])
  betas[betas == 1] <- max(betas[betas < 1])  
  
  if(platform == 27){
    loci <- IlluminaHumanMethylation27kanno.ilmn12.hg19::Locations
    locus <- intersect(row.names(betadat), row.names(loci))
    betadat <- betadat[locus,]
    locus <- loci[locus,]
  }else if(platform == 450){
    loci <- IlluminaHumanMethylation450kanno.ilmn12.hg19::Locations
    locus <- intersect(row.names(betadat), row.names(loci))
    betadat <- betadat[locus,]
    locus <- loci[locus,]
  }else if(platform == 850){
    loci <- IlluminaHumanMethylationEPICanno.ilm10b4.hg19::Locations
    locus <- intersect(row.names(betadat), row.names(loci))
    betadat <- betadat[locus,]
    locus <- loci[locus,]
  }
  
  cl <- bumphunter::clusterMaker(locus$chr, locus$pos, maxGap = maxgap)
  
  dmrinfor <- bumphunter::regionFinder(x = betadat[,1], chr = locus$chr, 
                                       pos = locus$pos, cluster = cl, 
                                       maxGap = maxgap, cutoff = 0, 
                                       order = FALSE)
  dmrinfor <- dmrinfor[c('cluster', 'clusterL', 'chr', 'start', 'end')]
  names(dmrinfor)[2] <- 'probenum'
  names(dmrinfor)[1] <- 'DMR'
  
  betadat <- as.data.frame(betadat, stringsAsFactors = FALSE)
  betadat$dmrname <- cl
  betadat <- betadat[,c(ncol(betadat), 1:(ncol(betadat) - 1))]
  betadat$dmrname <- paste0('DMR', betadat$dmrname)
  
  betadat <- summaryfeature(dat = betadat, featurecolidx = 1)
  
  if(is.null(betadat)){
    
    return(NULL)
  }
  
  dmrnames <- row.names(betadat)
  dmridces <- gsub(pattern = 'DMR', replacement = '', x = dmrnames)
  dmridces <- as.numeric(dmridces)
  dmrorders <- match(1:length(dmrnames), dmridces)
  betadat <- betadat[dmrorders,]
  
  #DMR-probe annotation
  probemapping <- data.frame(Probe = row.names(locus), 
                             DMR = cl, stringsAsFactors = FALSE)
  probemapping <- probemapping[order(probemapping$DMR, probemapping$Probe),]
  row.names(probemapping) <- 1:nrow(probemapping)
  probemapping <- merge(probemapping, dmrinfor, by = c('DMR'))
  
  probepart <- probeannotation(platform = platform, 
                               finalprobes = probemapping$Probe)
  probepart <- probepart[-2]
  probemapping <- merge(probemapping, probepart, by = c('Probe'))
  
  probemapping <- probemapping[,c(2, 4, 5, 6, 3, 
                                  1, 7, 8, 9, 10)]
  
  names(probemapping)[c(3, 4, 5, 7, 8)] <- c('DMR_start', 'DMR_end', 
                                             'Probe_num', 
                                             'Probe_pos', 'Probe_strand')
  probemapping <- probemapping[order(probemapping$DMR, probemapping$Probe_pos),]
  probemapping$DMR <- paste0('DMR', probemapping$DMR)
  probemapping <- unique(probemapping)
  row.names(probemapping) <- 1:nrow(probemapping)
  
  #DMR-gene annotation
  dmrs <- probemapping[,c(1, 2, 3, 4)]
  dmrs <- unique(dmrs)
  row.names(dmrs) <- 1:nrow(dmrs)
  
  dmrfrags <- paste0(dmrs$chr, ':', dmrs$DMR_start, '-', dmrs$DMR_end)
  
  genemapping <- coverredtss(fragments = dmrfrags, tssradius = TSSradius, ignorestrand = ignorestrand)
  
  if(is.null(genemapping)){
    res <- list(betadat = betadat, 
                dmrprobemapping = probemapping)
    return(res)
  }
  
  dmrs$frag <- dmrfrags
  dmrs$fragidx <- as.numeric(row.names(dmrs))
  genemapping <- merge(dmrs, genemapping, by = c('frag'))
  genemapping <- genemapping[order(genemapping$fragidx, 
                                   genemapping$start, 
                                   genemapping$TSSdistance, 
                                   genemapping$geneid),]
  genemapping <- unique(genemapping)
  genemapping <- genemapping[c('DMR', 'chr', 'DMR_start', 'DMR_end', 
                               'geneid', 'genename', 
                               'start', 'end', 'strand', 'TSSdistance')]
  colnames(genemapping)[c(7, 8, 9, 10)] <- c('Gene_start', 'Gene_end', 
                                             'Gene_strand', 'DMR_TSS_distance')
  row.names(genemapping) <- 1:nrow(genemapping)
  
  res <- list(betadat = betadat, 
              dmrprobemapping = probemapping, 
              dmrgenemapping = genemapping)
  
  return(res)
  
}




